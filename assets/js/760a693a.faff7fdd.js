"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[594],{8876:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var n=r(4848),o=r(8453);const s={sidebar_position:6},i="Circe (JSON)",a={id:"Modules/Circe",title:"Circe (JSON)",description:"Circe is a JSON library for Scala.",source:"@site/../docs/Modules/Circe.md",sourceDirName:"Modules",slug:"/Modules/Circe",permalink:"/big-data-types/docs/Modules/Circe",draft:!1,unlisted:!1,editUrl:"https://github.com/data-tools/big-data-types/edit/main/website/../docs/Modules/Circe.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Cassandra",permalink:"/big-data-types/docs/Modules/Cassandra"},next:{title:"Quick Start",permalink:"/big-data-types/docs/QuickStart"}},c={},l=[];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...e.components},{Details:r}=t;return r||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"circe-json",children:"Circe (JSON)"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://circe.github.io/circe/",children:"Circe"})," is a JSON library for Scala."]}),"\n",(0,n.jsxs)(t.p,{children:["The Circe module of this library allows to convert ",(0,n.jsx)(t.code,{children:"Json"})," objects (from ",(0,n.jsx)(t.a,{href:"https://circe.github.io/circe/",children:"Circe"}),") to any other type in the library."]}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsx)(t.p,{children:"For now only conversions from Circe to other types are available. Other types to Circe are not ready yet."})}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsxs)(t.p,{children:["Json objects do not have very concrete types, meaning that ",(0,n.jsx)(t.code,{children:"number"})," is a type,\nbut more specific types like ",(0,n.jsx)(t.code,{children:"integer"}),", ",(0,n.jsx)(t.code,{children:"float"})," or others do not exists.\nBecause of that, any conversion between types will convert ",(0,n.jsx)(t.code,{children:"number"})," into ",(0,n.jsx)(t.code,{children:"Decimal"})," types,\nas ",(0,n.jsx)(t.code,{children:"Decimal"})," is the only one that can ensure the precision of any arbitrary number"]})}),"\n",(0,n.jsxs)(r,{children:[(0,n.jsx)("summary",{children:"About Circe and private types"}),(0,n.jsx)("p",{children:(0,n.jsxs)(t.p,{children:["Circe has more specific types than ",(0,n.jsx)(t.code,{children:"JNumber"}),", like ",(0,n.jsx)(t.code,{children:"JLong"}),", ",(0,n.jsx)(t.code,{children:"JDouble"})," and others,\nbut all of them are private to Circe itself, so we can not use them, not even for matching types during conversions.\nIn any case, even if we were able to use them, when parsing a JSON string (probably most of the cases)\nwe can not detect the specific types, we could only guess them from the data."]})})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-scala",children:'import io.Circe.Json\nimport org.datatools.bigdatatypes.circe.CirceTypeConversion.*\nimport org.datatools.bigdatatypes.formats.Formats.implicitDefaultFormats\nimport org.datatools.bigdatatypes.spark.SqlInstanceToSpark.InstanceSyntax\nimport org.datatools.bigdatatypes.bigquery.SqlInstanceToBigQuery.*\n\n  val circeJson: Json = Json.fromFields(List(\n    ("id", Json.fromString("test")),\n    ("foo", Json.fromString("test")),\n    ("bar", Json.fromInt(1))\n  ))\n\n  val sparkSchema: StructType = circeJson.asSparkSchema\n  val bqSchema: Schema = circeJson.asBigQuery.schema\n'})}),"\n",(0,n.jsx)(t.p,{children:"Or if you do it from a JSON parsed using Circe:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-scala",children:'import io.circe._, io.circe.parser._\n\nimport org.datatools.bigdatatypes.circe.CirceTypeConversion.*\nimport org.datatools.bigdatatypes.formats.Formats.implicitDefaultFormats\nimport org.datatools.bigdatatypes.spark.SqlInstanceToSpark.InstanceSyntax\nimport org.datatools.bigdatatypes.bigquery.SqlInstanceToBigQuery.*\n\nval rawJson: String = """\n{\n  "foo": "bar",\n  "baz": 123,\n  "list of stuff": [ 4, 5, 6 ]\n}\n"""\nval parseResult = parse(rawJson)\n// parseResult: Either[ParsingFailure, Json]\nval sparkSchema = parseResult.map(j => j.asSparkSchema)\n// sparkSchema: Either[ParsingFailure, StructType]\nval bqSchema = parseResult.map(j => j.asBigQuery.schema)\n// bqSchema: Either[ParsingFailure, Schema]\n'})}),"\n",(0,n.jsx)(t.hr,{})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>a});var n=r(6540);const o={},s=n.createContext(o);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);