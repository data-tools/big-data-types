"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[883],{4650:(a,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var s=t(4848),n=t(8453);const i={sidebar_position:6},o="Transformations",r={id:"Transformations",title:"Transformations",description:"Transformations can be applied easily during conversions. For example, field names can be modified.",source:"@site/../docs/Transformations.md",sourceDirName:".",slug:"/Transformations",permalink:"/big-data-types/docs/Transformations",draft:!1,unlisted:!1,editUrl:"https://github.com/data-tools/big-data-types/edit/main/website/../docs/Transformations.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Quick Start",permalink:"/big-data-types/docs/QuickStart"},next:{title:"Multiple Modules",permalink:"/big-data-types/docs/MultipleModules"}},l={},c=[{value:"Implicit Formats",id:"implicit-formats",level:2},{value:"DefaultFormats",id:"defaultformats",level:3},{value:"SnakifyFormats",id:"snakifyformats",level:3},{value:"Creating a custom Formats",id:"creating-a-custom-formats",level:3}];function d(a){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...a.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"transformations",children:"Transformations"}),"\n",(0,s.jsx)(e.p,{children:"Transformations can be applied easily during conversions. For example, field names can be modified."}),"\n",(0,s.jsx)(e.h2,{id:"implicit-formats",children:"Implicit Formats"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"Formats"})," can handle different configurations that we want to apply to schemas, like transforming field names,\ndefining precision for numeric types and so on."]}),"\n",(0,s.jsxs)(e.p,{children:["They can be used by creating an ",(0,s.jsx)(e.code,{children:"implicit val"})," with a ",(0,s.jsx)(e.a,{href:"https://github.com/data-tools/big-data-types/blob/main/core/src/main/scala_3/org/datatools/bigdatatypes/formats/Formats.scala",children:"Formats"}),"\nclass or by importing one of the available implicit vals in ",(0,s.jsx)(e.code,{children:"Formats"})," object"]}),"\n",(0,s.jsx)(e.h3,{id:"defaultformats",children:"DefaultFormats"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"DefaultFormats"})," is a trait that applies no transformation to field names"]}),"\n",(0,s.jsx)(e.p,{children:"To use it, you can create an implicit val:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-scala",children:"import org.datatools.bigdatatypes.formats.{Formats, DefaultFormats}\nimplicit val formats: Formats = DefaultFormats\n"})}),"\n",(0,s.jsx)(e.p,{children:"or just import the one available:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-scala",children:"import org.datatools.bigdatatypes.formats.Formats.implicitDefaultFormats\n"})}),"\n",(0,s.jsx)(e.admonition,{type:"info",children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"Formats"})," is required in the scope for all the transformations, even if no transformations are needed.\nIn this case, ",(0,s.jsx)(e.code,{children:"implicitDefaultFormats"})," can be imported and no transformation will be applied."]})}),"\n",(0,s.jsx)(e.h3,{id:"snakifyformats",children:"SnakifyFormats"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"SnakifyFormats"})," is a trait that converts ",(0,s.jsx)(e.strong,{children:"camelCase"})," field names to ",(0,s.jsx)(e.strong,{children:"snake_case"})," names"]}),"\n",(0,s.jsx)(e.p,{children:"To use it, you can create an implicit val:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-scala",children:"import org.datatools.bigdatatypes.formats.{Formats, SnakifyFormats}\nimplicit val formats: Formats = SnakifyFormats\n"})}),"\n",(0,s.jsx)(e.p,{children:"or just import the one available:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-scala",children:"import org.datatools.bigdatatypes.formats.Formats.implicitSnakifyFormats\n"})}),"\n",(0,s.jsx)(e.h3,{id:"creating-a-custom-formats",children:"Creating a custom Formats"}),"\n",(0,s.jsx)(e.p,{children:"Formats can be extended, so if we want to transform keys differently, for example adding a suffix to all of our fields"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-scala",children:'import org.datatools.bigdatatypes.formats.Formats\ntrait SuffixFormats extends Formats {\n  override def transformKey[A <: SqlType](name: String, t: A): String = key + "_at"\n}\nobject SuffixFormats extends SuffixFormats\n'})}),"\n",(0,s.jsx)(e.p,{children:'All your field names will have "_at" at the end.'}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"t"})," is the Type of the field so you can decide how to transform your keys based on the type with a simple pattern matching"]})]})}function m(a={}){const{wrapper:e}={...(0,n.R)(),...a.components};return e?(0,s.jsx)(e,{...a,children:(0,s.jsx)(d,{...a})}):d(a)}},8453:(a,e,t)=>{t.d(e,{R:()=>o,x:()=>r});var s=t(6540);const n={},i=s.createContext(n);function o(a){const e=s.useContext(i);return s.useMemo((function(){return"function"==typeof a?a(e):{...e,...a}}),[e,a])}function r(a){let e;return e=a.disableParentContext?"function"==typeof a.components?a.components(n):a.components||n:o(a.components),s.createElement(i.Provider,{value:e},a.children)}}}]);